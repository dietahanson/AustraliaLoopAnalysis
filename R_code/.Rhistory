source('~/Documents/Australia/R_code/Raymond_code/example1.R')
dim(temp_response)[2]>1
temp_response
rowSums(temp_response)
temp_response <- -adjwA[, cm_idx]
dim(temp_response)[2]>1
temp_response <- rowSums(temp_response)
temp_response <- -adjwA[, cm_idx]
temp_response
dim(temp_response)
dim(temp_response)[2]>1
cm_idx
node_names
length(temp_response)
is.matrix(temp_response)
temp_response <- -adjwA[, cm_idx]
is.data.frame(temp_response)
head(temp_response)
temp_response$Cats
is.matrix(temp_response)
x <- read.table("macquarie_interactions.csv", sep=",", header=TRUE)
nwrand <- 1000 ## number of randomisations with different random weights on interaction strengths
max_nwrand <- 20*nwrand ##try a maximum of this many realisations to get the nwrand results
## validation data: what can we use to ground-truth our models?
## these are responses to suppression of cats and myxoma (i.e. rabbits increased, tall tussock decreased, and cats decreased)
model_validation <- matrix(c("Rabbits", 1, "Tall tussock vegetation", -1, "Cats", -1), nrow=3, ncol=2, byrow=TRUE)
colnames(model_validation) <- c("response_node", "response_value")
## get the list of unique names within these interactions
node_names <- unique(union(x$To, x$From))
heda(x)
head(x)
stable_count_cm <- 0 ## number of realisations that were stable
## summary of predictions for each element in the model
rsummary_cm <- matrix(0, nrow=3, ncol=length(node_names))
rsummary_cm
rownames(rsummary_cm) <- c("Negative", "Zero", "Positive")
colnames(rsummary_cm) <- node_names
rsummary_cm
cm_idx <- grep("(cats|myxoma)", node_names, ignore.case=TRUE)
pcm_idx <- grep("[^(cats|myxoma)]", node_names, ignore.case=TRUE) ##which elements in the model are relevant for the eradication project (not cats or myxo)
cm_idx
pcm_node_names <- node_names[pcm_idx]
stable_count_pcm <- 0 ## number of realisations that passed the additional stability test (after the removal of cats and myxo from the model)
pcm_results_cols <- grep("(rabbits|rats|mice)", node_names, ignore.case=TRUE) ## the columns in the A matrix that give the responses to perturbations of our eradication target species
pcm_results_cols
## summary of predictions for each element in the model
rsummary_pcm <- matrix(0, nrow=3, ncol=length(pcm_node_names))
rownames(rsummary_pcm) <- c("Negative", "Zero", "Positive")
colnames(rsummary_pcm) <- pcm_node_names
## summary of predictions for each element in the model, but only for the subset of simulations in which the target species were actually suppressed
rsummary_pcm_subset <- matrix(0, nrow=3, ncol=length(pcm_node_names)) ##summary for successful runs
rownames(rsummary_pcm_subset) <- c("Negative", "Zero", "Positive")
colnames(rsummary_pcm_subset) <- pcm_node_names
diagval_max <- -0.25 ## maximum allowable value for self-limitation links
n <- length(node_names) ##number of nodes
n_pcm <- length(pcm_node_names) ##number of nodes once cats and myxo removed
cat(sprintf("Main loop started at: %s\n", date()))
## initialise the interactions matrix A
A <- matrix(0, nrow=n, ncol=n)
colnames(A) <- node_names
rownames(A) <- node_names
if (grepl("(unknown|minor)", x[k, ]$Importance, ignore.case=TRUE)) {
## ignore "minor" or "unknown" links
next
}
if (grepl("(unknown|minor)", x[1, ]$Importance, ignore.case=TRUE)) {
## ignore "minor" or "unknown" links
next
}
this_from <- as.character(x[k, ]$From) ## the "from" element of the interaction
for (k in (1:dim(x)[1])) {  ##from 1 to the total number of links
if (grepl("(unknown|minor)", x[k, ]$Importance, ignore.case=TRUE)) {
## ignore "minor" or "unknown" links
next
}
this_from <- as.character(x[k, ]$From) ## the "from" element of the interaction
this_to <- as.character(x[k, ]$To) ## the "to" element of the interaction
if (grepl("competition", x[k, ]$Type, ignore.case=TRUE)) {
A[this_from, this_to] <- -1
A[this_to, this_from] <- -1
} else if (grepl("habitat", x[k, ]$Type, ignore.case=TRUE) || grepl("positive", x[k, ]$Type, ignore.case=TRUE)) {
A[this_to, this_from] <- 1
} else if (grepl("limiting", x[k, ]$Type, ignore.case=TRUE)) {
A[this_to, this_from] <- -1
} else if (grepl("negative", x[k, ]$Type, ignore.case=TRUE)) {
A[this_to, this_from] <- -1
} else if (grepl("predator-prey", x[k, ]$Type, ignore.case=TRUE)) {
A[this_from, this_to] <- 1
A[this_to, this_from] <- -1
} else if (grepl("scavenging", x[k, ]$Type, ignore.case=TRUE)) {
A[this_from, this_to] <- 1
} else {
stop(sprintf("unrecognised link type %s (%s to %s)", x[k, ]$Type, this_from, this_to))
}
}
this_valid_count <- 0
a
A
## randomisation of weights in A, in range 0.01-1
wA <- matrix(runif(n^2), nrow=n)*0.99+0.01
wA <- wA*sign(A)
wA
## but make sure diagonals are between -1 and diagval_max
temp <- diag(rep(1, dim(A)[1]))
wA <- wA*(1-temp)+(-1-diagval_max)*diag(runif(n))+diagval_max*temp
wA
## calculate the response, and check the validation criteria
adjwA <- -solve(wA) ##negative inverse of wA
adjwA
adjwA[abs(adjwA)<1e-07] <- 0 ## set very small responses to zero
adjwA
## check that response fits validation data
this_valid <- TRUE
temp_response <- -adjwA[, cm_idx]
if (dim(temp_response)[2]>1) {
## sum response over the individual responses
temp_response <- rowSums(temp_response)
}
temp_response
for (k in 1:dim(model_validation)[1]) {
temp_response <- -adjwA[, cm_idx]
if (dim(temp_response)[2]>1) {
## sum response over the individual responses
temp_response <- rowSums(temp_response)
}
temp_response <- sign(temp_response)
if (temp_response[model_validation[k, "response_node"]] != model_validation[k, "response_value"]) {
this_valid <- FALSE ##not valid
break
}
}
temp_response
source('~/Documents/Australia/R_code/Raymond_code/example1.R')
rsummary_cm
temp
?as.double
pcm_results_cols
## predicted response to eradication project
temp <- -adjwA[, pcm_results_cols]
temp
adjwA
dim(temp)[2]
dim(temp)
temp
temp <- rowSums(temp)
temp
temp <- sign(temp)
temp
rsummary_pcm[1, ]
rsummary_pcm[1, ]+as.double(temp==-1)
library(reshape2)
stefgroup <- read.csv("stefgroups.csv",  #get stefanis groups
header = T,
stringsAsFactors = F)
setwd("~/Documents/Australia/R_code")
stefgroup <- read.csv("stefgroups.csv",  #get stefanis groups
header = T,
stringsAsFactors = F)
tg <- read.delim("tg_martu.txt", #get trophic groups from n_w
header = T,
stringsAsFactors = F,
sep = "\t")
tg$Species <- gsub("_", " ", tg$Species)  #fix species names
tg$Species <- gsub("human", "Homo sapiens", tg$Species)
tg$Species <- gsub("\\*", "", tg$Species)
aic <- read.delim("aic_martu.txt", #get aic groups from n_w
header = T,
stringsAsFactors = F,
sep = "\t")
aic$Species <- gsub("_", " ", aic$Species) #fix species names
aic$Species <- gsub("human", "Homo sapiens", aic$Species)
aic$Species <- gsub("\\*", "", aic$Species)
groups <- data.frame(common = stefgroup$common, #make table of species names
latin = stefgroup$latin,
stefgroup = stefgroup$stefgroup)
groups$tg <- tg$X.TroG[match(groups$latin, tg$Species)] #add trophic groups
groups$aic <- aic$X.AicG[match(groups$latin, aic$Species)] #add aic groups
groups[is.na(groups$tg),] #returns species with no group match in tg
groups[is.na(groups$aic),] #returns species with no group match in aic
hotnet <- read.csv("hotnet.csv",  #get network
header = T,
stringsAsFactors = F)
hotnet$weight <- NULL #take away weights
head(groups)
head(aic)
groups <- data.frame(common = stefgroup$common, #make table of species names
latin = stefgroup$latin,
stefgroup = stefgroup$stefgroup)
head(groups)
head(stefgroup)
stefgroup <- read.csv("stefgroups.csv",  #get stefanis groups
header = T,
stringsAsFactors = F)
tg <- read.delim("tg_martu.txt", #get trophic groups from n_w
header = T,
stringsAsFactors = F,
sep = "\t")
tg$Species <- gsub("_", " ", tg$Species)  #fix species names
tg$Species <- gsub("human", "Homo sapiens", tg$Species)
tg$Species <- gsub("\\*", "", tg$Species)
aic <- read.delim("aic_martu.txt", #get aic groups from n_w
header = T,
stringsAsFactors = F,
sep = "\t")
aic$Species <- gsub("_", " ", aic$Species) #fix species names
aic$Species <- gsub("human", "Homo sapiens", aic$Species)
aic$Species <- gsub("\\*", "", aic$Species)
groups <- data.frame(common = stefgroup$common, #make table of species names
latin = stefgroup$latin,
stefgroup = stefgroup$stefgroup)
groups$tg <- tg$X.TroG[match(groups$latin, tg$Species)] #add trophic groups
groups$aic <- aic$X.AicG[match(groups$latin, aic$Species)] #add aic groups
groups[is.na(groups$tg),] #returns species with no group match in tg
groups[is.na(groups$aic),] #returns species with no group match in aic
head(groups)
levels(groups$stefgroup)
hotnet$From <- as.factor(groups$stefgroup[match(hotnet$predator, #match predators
groups$latin)])
cat(sum(is.na(hotnet$From)), #print how many did not match
"predators with missing matches:")
hotnet[is.na(hotnet$From),]
hotnet$To <- as.factor(groups$stefgroup[match(hotnet$prey,   #match prey
groups$latin)])
cat(sum(is.na(hotnet$To)), #print how many did not match
"prey with missing matches:")
hotnet[is.na(hotnet$To),]
hotnet$Type <- "Predator-prey" #add interaction type
head(hotnet)
hotnetsmall <- hotnet[!duplicated(hotnet[c("From","To")]),]
heda(hotnetsmall)
head(hotnetsmall)
hotnetsmall <- hotnet[!duplicated(hotnet[c("From","To")]), c("From", "To", "Type")]
head(hotnetsmall)
x=read.table('hotgrouped.csv',sep=',',header=T)
nwrand=1000 # number of randomisations with different interaction strengths
max_nwrand=20*nwrand #try a maximum of this many realisations
# validation data: what can we use to ground-truth our models?
# these are responses to removal of humans
model_validation=matrix(c('camel',1,'fox',1,'betong',-1),
nrow=3,ncol=2,byrow=TRUE)
colnames(model_validation)=c('response_node','response_value')
model_validation
# get the list of unique names within these interactions
node_names=unique(union(x$To,x$From))
[3,] "betong"      "-1"
node_names
write.csv(hotnetsmall, file = "hotgrouped.csv", row.names = F)
x=read.table('hotgrouped.csv',sep=',',header=T)
# get the list of unique names within these interactions
node_names=unique(union(x$To,x$From))
node_names
stable_count_h=0 # number of realisations that were stable
rsummary_h=matrix(0,nrow=3,ncol=length(node_names))
rownames(rsummary_h)=c('Negative','Zero','Positive')
colnames(rsummary_h)=node_names
rsummary_h
h_idx=grep('(human)',node_names,ignore.case=T)
h_idx
#h_idx=grep('(human)',node_names,ignore.case=T) #don't think we need this anymore
ph_idx=grep('[^(human)]',node_names,ignore.case=T) # all node names except humans
ph_idx
ph_node_names=node_names[ph_idx]
ph_node_names
stable_count_ph=0 # number of models that passed the stability test post humans
ph_results_cols=grep('(camel|fox|betong)',node_names,ignore.case=T) # the columns in the A matrix that give the responses to perturbations of our eradication target species
ph_results_cols
# summary of predictions for each element in the model
rsummary_ph=matrix(0,nrow=3,ncol=length(ph_node_names))
rownames(rsummary_ph)=c('Negative','Zero','Positive')
colnames(rsummary_ph)=pcm_node_names
colnames(rsummary_ph)=ph_node_names
rsummary_ph
diagval_max=-0.25 # maximum allowable value for self-limitation links
n=length(node_names) #number of nodes
n=length(node_names) #number of nodes
n_ph=length(ph_node_names) #number of nodes once cats and myxo removed
cat(sprintf('Main loop started at: %s\n',date()))
flush.console()
# initialise the interactions matrix A
A=matrix(0,nrow=n,ncol=n)
colnames(A)=node_names
rownames(A)=node_names
A
for (k in (1:dim(x)[1])) {
this_from=as.character(x[k,]$From) # the "from" element of the interaction
this_to=as.character(x[k,]$To) # the "to" element of the interaction
if (grepl('competition',x[k,]$Type,ignore.case=T)) {
A[this_from,this_to]=-1
A[this_to,this_from]=-1
} else if (grepl('habitat',x[k,]$Type,ignore.case=T) || grepl('positive',x[k,]$Type,ignore.case=T)) {
A[this_to,this_from]=1
} else if (grepl('limiting',x[k,]$Type,ignore.case=T)) {
A[this_to,this_from]=-1
} else if (grepl('negative',x[k,]$Type,ignore.case=T)) {
A[this_to,this_from]=-1
} else if (grepl('predator-prey',x[k,]$Type,ignore.case=T)) {
A[this_from,this_to]=1
A[this_to,this_from]=-1
} else if (grepl('scavenging',x[k,]$Type,ignore.case=T)) {
A[this_from,this_to]=1
} else {
stop(sprintf('unrecognised link type %s (%s to %s)',x[k,]$Type,this_from,this_to))
}
}
A
x
hotnet[hotnet$To=="Snakes",]
hotnetsmall[hotnetsmall$To=="Snakes",]
this_valid_count=0
this_valid_count=0
# randomisation of weights in A, in range 0.01-1
wA=matrix(runif(n^2),nrow=n)*0.99+0.01
wA
node_names
wA=wA*sign(A)
wA
sign(0)
# but make sure diagonals are between -1 and diagval_max
temp=diag(rep(1,dim(A)[1]))
wA=wA*(1-temp)+(-1-diagval_max)*diag(runif(n))+diagval_max*temp
# calculate the response, and check the validation criteria
adjwA=-solve(wA) #negative inverse of wA
adjwA[abs(adjwA)<1e-07]=0 # set very small responses to zero
# check that response fits validation data
this_valid=1
(!all(Re(eigen(wA,only.values=T)$values)<0))
adjwA
# find the predicted response to cat/myxo suppression
temp=-adjwA[,h_idx]
temp
wA
